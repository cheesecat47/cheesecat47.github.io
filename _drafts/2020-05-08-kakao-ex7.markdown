---
layout: post
title: "[Algorithm] n-th system game"
date: 2020-05-08 15:00:00 +0900
categories: Programming
tags: [Algorithm, Programmers, Kakao]
# image: thumbnails/2020-01-18-Algorithm-baekjoon7562.png
---

# [from Programmers](https://programmers.co.kr/learn/courses/30/lessons/17687?language=python3){:target="blank"}

## Conditions

- 진법 `n`, 미리 구할 숫자 갯수 `t`, 게임에 참가하는 인원 `m`, 순서 `p`가 주어진다.
- 말해야 하는 숫자 `t`개를 공백없이 차례로 문자열로 나타낸다.
- 10~15는 각각 대문자 A~F로 출력한다.
- 0부터 `n`진법으로 바꾸고, 그 값을 계속 이은 문자열을 만든다.
- `t`개를 말해야 하므로 `game` 문자열의 길이가 `t * m + p`보다 길면 `n`진법으로 바꾸는 과정을 멈춘다.
- `answer`의 길이가 `t`가 될 때까지 `i * m + p`번째 문자를 이어붙인다.

## Brute force

```python
def solution(n, t, m, p):
    answer = ''
    
    num = 0
    game = ""
    while True:
        numToN = convertN(num, n)
        game += numToN
        
        if len(game) > (t * m + p):
            break
        num += 1
    
    for i in range(len(game)):
        if i % m == p - 1:
            answer += game[i]
        if len(answer) == t:
            break
    
    return answer


def convertN(num, n):
    if num == 0:
        return '0'
    
    digit = "0123456789ABCDEF"
    temp = ""
    
    while num:
        q, r = divmod(num, n)
        temp = digit[r] + temp
        num = q
    
    return temp
```

- 최대: 테스트 16 〉	통과 (37.41ms, 10.7MB)

## Big-O notation

- `convertN()`에서 while문은 $$ log_n\ num $$번 반복하게 된다. 이것을 확장하면 `convertN()`은 $$ O(log\ num) $$이다.
- 다만, `convertN()`에 필요한 실제 시간은 `num`이 0일 때 1, 1일 때 1, 2일 때 1, 3일 때 2, 4일 때 2 ... 이런 식으로 logscale로 증가하므로 while문에 걸리는 시간은 이 값을 합한 값이고, $$ 1+2+3+4+...+n $$인 $$ \frac{n(n+1)}{2} $$보다는 작을 것이므로 대략 $$ O(NlogN) $$에 가까울 것이다. 
- `answer`를 만드는 for문은 $$ O(t) $$만큼 동작한다.
- 결과적으로, $$ O(NlogN) $$ 시간에 동작한다.

## Optimization

```python
def convertN(num, n):
    if num == 0: 
        return '0'
    
    digit = "0123456789ABCDEF"
    temp = ""
    
    while num:
        num, r = divmod(num, n)
        temp = digit[r] + temp
    
    return temp
```

- 작은 차이긴 하지만, 굳이 `q`를 사용할 필요가 없다.

```python
def solution(n, t, m, p):
    answer = ''
    
    num = 0
    game = ""
    targetLen = t * m + p
    while len(game) < targetLen:
        game += convertN(num, n)
        num += 1
    
    for i in range(len(game)):
        if i % m == p - 1:
            answer += game[i]
        if len(answer) == t:
            break
    
    return answer
```

- `numToN` 변수도 안 써도 돼서 제거.
- `t * m + p`도 매 번 연산할 필요가 없다.
- while문 조건을 바꿔버리면 if문도 뺄 수 있다.
- 복잡하지 않은 문제라서 이 정도가 최대인 것 같다.

- 최대: 테스트 15 〉	통과 (36.15ms, 10.9MB)

## Remember

- 진법 변환하는 방법 기억해두면 좋을 것 같다.
- `divmod(a, b)`에서 `a`가 0일 때 `q`가 아무것도 반환되지 않았다. 주의. 
